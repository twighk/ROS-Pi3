/*
 * Module code.
 *
 * Generated by SIP 4.17
 */

#include "sipAPIPyKDL.h"

#line 172 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 13 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 281 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 19 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 201 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 25 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 159 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 29 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 223 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 33 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 39 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 102 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 45 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 352 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 51 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 253 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 55 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 59 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 44 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 63 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 100 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 67 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 207 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 71 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 75 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 25 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 80 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 64 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 85 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 81 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 90 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 103 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 95 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 133 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 99 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 153 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 103 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

/* Define the strings used by this module. */
const char sipStrings_PyKDL[] = {
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', '_', 'g', 'i', 'v', 'e', 'n', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', '_', 'n', 's', 'o', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'N', 'R', '_', 'J', 'L', 0,
    'J', 'n', 't', 'S', 'p', 'a', 'c', 'e', 'I', 'n', 'e', 'r', 't', 'i', 'a', 'M', 'a', 't', 'r', 'i', 'x', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'w', 'd', 'l', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'L', 'M', 'A', 0,
    'g', 'e', 't', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'C', 'h', 'a', 'i', 'n', 'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'N', 'R', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', 0,
    'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', 'J', 'a', 'c', 'o', 'b', 'i', 'a', 'n', 0,
    'R', 'i', 'g', 'i', 'd', 'B', 'o', 'd', 'y', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'J', 'o', 'i', 'n', 't', ':', ':', 'J', 'o', 'i', 'n', 't', 'T', 'y', 'p', 'e', 0,
    'g', 'e', 't', 'N', 'r', 'O', 'f', 'S', 'e', 'g', 'm', 'e', 'n', 't', 's', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'f', 'F', 'r', 'a', 'm', 'e', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'f', 'P', 'o', 'i', 'n', 't', 0,
    'J', 'n', 't', 'T', 'o', 'C', 'o', 'r', 'i', 'o', 'l', 'i', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'D', 'y', 'n', 'P', 'a', 'r', 'a', 'm', 0,
    'g', 'e', 't', 'N', 'r', 'O', 'f', 'J', 'o', 'i', 'n', 't', 's', 0,
    'g', 'e', 't', 'F', 'r', 'a', 'm', 'e', 'T', 'o', 'T', 'i', 'p', 0,
    'G', 'e', 't', 'Q', 'u', 'a', 't', 'e', 'r', 'n', 'i', 'o', 'n', 0,
    'J', 'n', 't', 'T', 'o', 'G', 'r', 'a', 'v', 'i', 't', 'y', 0,
    'D', 'H', '_', 'C', 'r', 'a', 'i', 'g', '1', '9', '8', '9', 0,
    'G', 'e', 't', 'T', 'w', 'i', 's', 't', 'D', 'o', 't', 0,
    'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'V', 'e', 'l', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 'J', 'S', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 'T', 'S', 0,
    'J', 'n', 't', 'A', 'r', 'r', 'a', 'y', 'V', 'e', 'l', 0,
    'g', 'e', 't', 'T', 'y', 'p', 'e', 'N', 'a', 'm', 'e', 0,
    'J', 'o', 'i', 'n', 't', 'O', 'r', 'i', 'g', 'i', 'n', 0,
    'G', 'e', 't', 'E', 'u', 'l', 'e', 'r', 'Z', 'Y', 'X', 0,
    'G', 'e', 't', 'E', 'u', 'l', 'e', 'r', 'Z', 'Y', 'Z', 0,
    'G', 'e', 't', 'R', 'o', 't', 'A', 'n', 'g', 'l', 'e', 0,
    'R', 'e', 'v', 'e', 'r', 's', 'e', 'S', 'i', 'g', 'n', 0,
    '_', '_', 's', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    '_', '_', 'g', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    's', 't', 'd', ':', ':', 's', 't', 'r', 'i', 'n', 'g', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'B', 'a', 's', 'e', 0,
    'g', 'e', 't', 'S', 'e', 'g', 'm', 'e', 'n', 't', 0,
    'a', 'd', 'd', 'S', 'e', 'g', 'm', 'e', 'n', 't', 0,
    's', 'e', 't', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'g', 'e', 't', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'S', 'e', 't', 'I', 'n', 'v', 'e', 'r', 's', 'e', 0,
    'J', 'n', 't', 'T', 'o', 'M', 'a', 's', 's', 0,
    'V', 'e', 'c', 't', 'o', 'r', 'V', 'e', 'l', 0,
    'd', 'o', 'u', 'b', 'l', 'e', 'V', 'e', 'l', 0,
    's', 'e', 't', 'L', 'a', 'm', 'b', 'd', 'a', 0,
    'C', 'a', 'r', 't', 'T', 'o', 'J', 'n', 't', 0,
    'J', 'n', 't', 'T', 'o', 'C', 'a', 'r', 't', 0,
    's', 'e', 't', 'C', 'o', 'l', 'u', 'm', 'n', 0,
    'g', 'e', 't', 'C', 'o', 'l', 'u', 'm', 'n', 0,
    'J', 'o', 'i', 'n', 't', 'A', 'x', 'i', 's', 0,
    'T', 'r', 'a', 'n', 's', 'A', 'x', 'i', 's', 0,
    'I', 'n', 't', 'e', 'g', 'r', 'a', 't', 'e', 0,
    'S', 'e', 't', 'T', 'o', 'Z', 'e', 'r', 'o', 0,
    'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'e', 0,
    'T', 'w', 'i', 's', 't', 'V', 'e', 'l', 0,
    'G', 'e', 't', 'T', 'w', 'i', 's', 't', 0,
    'G', 'e', 't', 'F', 'r', 'a', 'm', 'e', 0,
    'F', 'r', 'a', 'm', 'e', 'V', 'e', 'l', 0,
    'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 0,
    'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', 0,
    'S', 'u', 'b', 't', 'r', 'a', 'c', 't', 0,
    'J', 'n', 't', 'A', 'r', 'r', 'a', 'y', 0,
    'g', 'e', 't', 'C', 'h', 'a', 'i', 'n', 0,
    'a', 'd', 'd', 'C', 'h', 'a', 'i', 'n', 0,
    'g', 'e', 't', 'J', 'o', 'i', 'n', 't', 0,
    'a', 'd', 'd', 'D', 'e', 'l', 't', 'a', 0,
    'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 0,
    'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    '_', '_', 'i', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'i', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'r', 'e', 'p', 'r', '_', '_', 0,
    'c', 'o', 'l', 'u', 'm', 'n', 's', 0,
    'g', 'e', 't', 'M', 'a', 's', 's', 0,
    'g', 'e', 't', 'T', 'y', 'p', 'e', 0,
    'g', 'e', 't', 'N', 'a', 'm', 'e', 0,
    'R', 'o', 't', 'A', 'x', 'i', 's', 0,
    '_', '_', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'd', 'i', 'v', '_', '_', 0,
    '_', '_', 'm', 'u', 'l', '_', '_', 0,
    '_', '_', 'n', 'e', 'g', '_', '_', 0,
    'D', 'i', 'v', 'i', 'd', 'e', 0,
    'r', 'e', 's', 'i', 'z', 'e', 0,
    'g', 'e', 't', 'C', 'O', 'G', 0,
    'T', 'r', 'a', 'n', 's', 'Z', 0,
    'T', 'r', 'a', 'n', 's', 'Y', 0,
    'T', 'r', 'a', 'n', 's', 'X', 0,
    't', 'o', 'r', 'q', 'u', 'e', 0,
    'W', 'r', 'e', 'n', 'c', 'h', 0,
    'G', 'e', 't', 'R', 'P', 'Y', 0,
    'G', 'e', 't', 'R', 'o', 't', 0,
    'D', 'o', 'R', 'o', 't', 'Z', 0,
    'D', 'o', 'R', 'o', 't', 'Y', 0,
    'D', 'o', 'R', 'o', 't', 'X', 0,
    '_', '_', 'n', 'e', '_', '_', 0,
    '_', '_', 'e', 'q', '_', '_', 0,
    'V', 'e', 'c', 't', 'o', 'r', 0,
    'd', 'e', 'r', 'i', 'v', 0,
    't', 'w', 'i', 's', 't', 0,
    'f', 'o', 'r', 'c', 'e', 0,
    'U', 'n', 'i', 't', 'Z', 0,
    'U', 'n', 'i', 't', 'Y', 0,
    'U', 'n', 'i', 't', 'X', 0,
    'E', 'q', 'u', 'a', 'l', 0,
    'v', 'a', 'l', 'u', 'e', 0,
    'P', 'y', 'K', 'D', 'L', 0,
    'g', 'r', 'a', 'd', 0,
    'r', 'o', 'w', 's', 0,
    'T', 'r', 'e', 'e', 0,
    'q', 'd', 'o', 't', 0,
    'p', 'o', 's', 'e', 0,
    'N', 'o', 'n', 'e', 0,
    'd', 'i', 'f', 'f', 0,
    'R', 'o', 't', '2', 0,
    'N', 'o', 'r', 'm', 0,
    'A', 'd', 'd', 0,
    'r', 'o', 't', 0,
    'v', 'e', 'l', 0,
    'D', 'H', 0,
    'q', 0,
    'M', 0,
    'w', 0,
    'z', 0,
};

int sipVH_PyKDL_0(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const JntArray& a0,const Twist& a1,JntArray& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND",new JntArray(a0),sipType_JntArray,NULL,new Twist(a1),sipType_Twist,NULL,&a2,sipType_JntArray,NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_1(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const JntArray& a0,const Frame& a1,JntArray& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND",new JntArray(a0),sipType_JntArray,NULL,new Frame(a1),sipType_Frame,NULL,&a2,sipType_JntArray,NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_2(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const JntArray& a0,const FrameVel& a1,JntArrayVel& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND",new JntArray(a0),sipType_JntArray,NULL,new FrameVel(a1),sipType_FrameVel,NULL,&a2,sipType_JntArrayVel,NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_3(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const JntArrayVel& a0,FrameVel& a1,int a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NDi",new JntArrayVel(a0),sipType_JntArrayVel,NULL,&a1,sipType_FrameVel,NULL,a2);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_4(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const JntArray& a0,Frame& a1,int a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NDi",new JntArray(a0),sipType_JntArray,NULL,&a1,sipType_Frame,NULL,a2);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}


PyDoc_STRVAR(doc_changeRefFrame, "changeRefFrame(Jacobian, Frame, Jacobian)");

extern "C" {static PyObject *func_changeRefFrame(PyObject *,PyObject *);}
static PyObject *func_changeRefFrame(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Jacobian* a0;
        const Frame* a1;
        Jacobian* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_Jacobian, &a0, sipType_Frame, &a1, sipType_Jacobian, &a2))
        {
            changeRefFrame(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeRefFrame, doc_changeRefFrame);

    return NULL;
}


PyDoc_STRVAR(doc_changeBase, "changeBase(Jacobian, Rotation, Jacobian)");

extern "C" {static PyObject *func_changeBase(PyObject *,PyObject *);}
static PyObject *func_changeBase(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Jacobian* a0;
        const Rotation* a1;
        Jacobian* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_Jacobian, &a0, sipType_Rotation, &a1, sipType_Jacobian, &a2))
        {
            changeBase(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeBase, doc_changeBase);

    return NULL;
}


PyDoc_STRVAR(doc_changeRefPoint, "changeRefPoint(Jacobian, Vector, Jacobian)");

extern "C" {static PyObject *func_changeRefPoint(PyObject *,PyObject *);}
static PyObject *func_changeRefPoint(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Jacobian* a0;
        const Vector* a1;
        Jacobian* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_Jacobian, &a0, sipType_Vector, &a1, sipType_Jacobian, &a2))
        {
            changeRefPoint(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeRefPoint, doc_changeRefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_MultiplyJacobian, "MultiplyJacobian(Jacobian, JntArray, Twist)");

extern "C" {static PyObject *func_MultiplyJacobian(PyObject *,PyObject *);}
static PyObject *func_MultiplyJacobian(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Jacobian* a0;
        const JntArray* a1;
        Twist* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_Jacobian, &a0, sipType_JntArray, &a1, sipType_Twist, &a2))
        {
            MultiplyJacobian(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_MultiplyJacobian, doc_MultiplyJacobian);

    return NULL;
}


PyDoc_STRVAR(doc_Divide, "Divide(JntArray, float, JntArray)\n"
    "Divide(JntArrayVel, float, JntArrayVel)\n"
    "Divide(JntArrayVel, doubleVel, JntArrayVel)\n"
    "Divide(JntSpaceInertiaMatrix, float, JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Divide(PyObject *,PyObject *);}
static PyObject *func_Divide(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        double a1;
        JntArray* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dJ9", sipType_JntArray, &a0, &a1, sipType_JntArray, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        double a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dJ9", sipType_JntArrayVel, &a0, &a1, sipType_JntArrayVel, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        const doubleVel* a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArrayVel, &a0, sipType_doubleVel, &a1, sipType_JntArrayVel, &a2))
        {
            Divide(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;
        double a1;
        JntSpaceInertiaMatrix* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dJ9", sipType_JntSpaceInertiaMatrix, &a0, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Divide, doc_Divide);

    return NULL;
}


PyDoc_STRVAR(doc_Multiply, "Multiply(JntArray, float, JntArray)\n"
    "Multiply(JntArrayVel, float, JntArrayVel)\n"
    "Multiply(JntArrayVel, doubleVel, JntArrayVel)\n"
    "Multiply(JntSpaceInertiaMatrix, float, JntSpaceInertiaMatrix)\n"
    "Multiply(JntSpaceInertiaMatrix, JntArray, JntArray)");

extern "C" {static PyObject *func_Multiply(PyObject *,PyObject *);}
static PyObject *func_Multiply(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        double a1;
        JntArray* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dJ9", sipType_JntArray, &a0, &a1, sipType_JntArray, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        double a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dJ9", sipType_JntArrayVel, &a0, &a1, sipType_JntArrayVel, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        const doubleVel* a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArrayVel, &a0, sipType_doubleVel, &a1, sipType_JntArrayVel, &a2))
        {
            Multiply(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;
        double a1;
        JntSpaceInertiaMatrix* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9dJ9", sipType_JntSpaceInertiaMatrix, &a0, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;
        const JntArray* a1;
        JntArray* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Multiply(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Multiply, doc_Multiply);

    return NULL;
}


PyDoc_STRVAR(doc_Subtract, "Subtract(JntArray, JntArray, JntArray)\n"
    "Subtract(JntArrayVel, JntArrayVel, JntArrayVel)\n"
    "Subtract(JntArrayVel, JntArray, JntArrayVel)\n"
    "Subtract(JntSpaceInertiaMatrix, JntSpaceInertiaMatrix, JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Subtract(PyObject *,PyObject *);}
static PyObject *func_Subtract(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        const JntArray* a1;
        JntArray* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        const JntArrayVel* a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, sipType_JntArrayVel, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        const JntArray* a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArray, &a1, sipType_JntArrayVel, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;
        const JntSpaceInertiaMatrix* a1;
        JntSpaceInertiaMatrix* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Subtract, doc_Subtract);

    return NULL;
}


PyDoc_STRVAR(doc_Add, "Add(JntArray, JntArray, JntArray)\n"
    "Add(JntArrayVel, JntArrayVel, JntArrayVel)\n"
    "Add(JntArrayVel, JntArray, JntArrayVel)\n"
    "Add(JntSpaceInertiaMatrix, JntSpaceInertiaMatrix, JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Add(PyObject *,PyObject *);}
static PyObject *func_Add(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        const JntArray* a1;
        JntArray* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        const JntArrayVel* a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, sipType_JntArrayVel, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntArrayVel* a0;
        const JntArray* a1;
        JntArrayVel* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArray, &a1, sipType_JntArrayVel, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;
        const JntSpaceInertiaMatrix* a1;
        JntSpaceInertiaMatrix* a2;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Add, doc_Add);

    return NULL;
}


PyDoc_STRVAR(doc_addDelta, "addDelta(Vector, Vector, float dt=1) -> Vector\n"
    "addDelta(Rotation, Vector, float dt=1) -> Rotation\n"
    "addDelta(Frame, Twist, float dt=1) -> Frame\n"
    "addDelta(Twist, Twist, float dt=1) -> Twist\n"
    "addDelta(Wrench, Wrench, float dt=1) -> Wrench\n"
    "addDelta(doubleVel, doubleVel, float dt=1) -> doubleVel\n"
    "addDelta(VectorVel, VectorVel, float dt=1) -> VectorVel\n"
    "addDelta(RotationVel, VectorVel, float dt=1) -> RotationVel\n"
    "addDelta(FrameVel, TwistVel, float dt=1) -> FrameVel");

extern "C" {static PyObject *func_addDelta(PyObject *,PyObject *);}
static PyObject *func_addDelta(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Vector* a0;
        const Vector* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
            Vector*sipRes;

            sipRes = new Vector(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const Rotation* a0;
        const Vector* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Rotation, &a0, sipType_Vector, &a1, &a2))
        {
            Rotation*sipRes;

            sipRes = new Rotation(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    {
        const Frame* a0;
        const Twist* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Frame, &a0, sipType_Twist, &a1, &a2))
        {
            Frame*sipRes;

            sipRes = new Frame(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    {
        const Twist* a0;
        const Twist* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
            Twist*sipRes;

            sipRes = new Twist(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const Wrench* a0;
        const Wrench* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
            Wrench*sipRes;

            sipRes = new Wrench(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const doubleVel* a0;
        const doubleVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
            doubleVel*sipRes;

            sipRes = new doubleVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const VectorVel* a0;
        const VectorVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const RotationVel* a0;
        const VectorVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_RotationVel, &a0, sipType_VectorVel, &a1, &a2))
        {
            RotationVel*sipRes;

            sipRes = new RotationVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    {
        const FrameVel* a0;
        const TwistVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_FrameVel, &a0, sipType_TwistVel, &a1, &a2))
        {
            FrameVel*sipRes;

            sipRes = new FrameVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_addDelta, doc_addDelta);

    return NULL;
}


PyDoc_STRVAR(doc_diff, "diff(Vector, Vector, float dt=1) -> Vector\n"
    "diff(Rotation, Rotation, float dt=1) -> Vector\n"
    "diff(Frame, Frame, float dt=1) -> Twist\n"
    "diff(Twist, Twist, float dt=1) -> Twist\n"
    "diff(Wrench, Wrench, float dt=1) -> Wrench\n"
    "diff(doubleVel, doubleVel, float dt=1) -> doubleVel\n"
    "diff(VectorVel, VectorVel, float dt=1) -> VectorVel\n"
    "diff(RotationVel, RotationVel, float dt=1) -> VectorVel\n"
    "diff(FrameVel, FrameVel, float dt=1) -> TwistVel");

extern "C" {static PyObject *func_diff(PyObject *,PyObject *);}
static PyObject *func_diff(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Vector* a0;
        const Vector* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
            Vector*sipRes;

            sipRes = new Vector(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const Rotation* a0;
        const Rotation* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Rotation, &a0, sipType_Rotation, &a1, &a2))
        {
            Vector*sipRes;

            sipRes = new Vector(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const Frame* a0;
        const Frame* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Frame, &a0, sipType_Frame, &a1, &a2))
        {
            Twist*sipRes;

            sipRes = new Twist(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const Twist* a0;
        const Twist* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
            Twist*sipRes;

            sipRes = new Twist(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const Wrench* a0;
        const Wrench* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
            Wrench*sipRes;

            sipRes = new Wrench(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const doubleVel* a0;
        const doubleVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
            doubleVel*sipRes;

            sipRes = new doubleVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const VectorVel* a0;
        const VectorVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const RotationVel* a0;
        const RotationVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_RotationVel, &a0, sipType_RotationVel, &a1, &a2))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const FrameVel* a0;
        const FrameVel* a1;
        double a2 = 1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_FrameVel, &a0, sipType_FrameVel, &a1, &a2))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_diff, doc_diff);

    return NULL;
}


PyDoc_STRVAR(doc_Equal, "Equal(Vector, Vector, float eps=epsilon) -> bool\n"
    "Equal(Rotation, Rotation, float eps=epsilon) -> bool\n"
    "Equal(Frame, Frame, float eps=epsilon) -> bool\n"
    "Equal(Twist, Twist, float eps=epsilon) -> bool\n"
    "Equal(Wrench, Wrench, float eps=epsilon) -> bool\n"
    "Equal(JntArray, JntArray, float eps=epsilon) -> bool\n"
    "Equal(JntArrayVel, JntArrayVel, float eps=epsilon) -> bool\n"
    "Equal(doubleVel, doubleVel, float eps=epsilon) -> bool\n"
    "Equal(VectorVel, VectorVel, float eps=epsilon) -> bool\n"
    "Equal(Vector, VectorVel, float eps=epsilon) -> bool\n"
    "Equal(VectorVel, Vector, float eps=epsilon) -> bool\n"
    "Equal(RotationVel, RotationVel, float eps=epsilon) -> bool\n"
    "Equal(Rotation, RotationVel, float eps=epsilon) -> bool\n"
    "Equal(RotationVel, Rotation, float eps=epsilon) -> bool\n"
    "Equal(FrameVel, FrameVel, float eps=epsilon) -> bool\n"
    "Equal(Frame, FrameVel, float eps=epsilon) -> bool\n"
    "Equal(FrameVel, Frame, float eps=epsilon) -> bool\n"
    "Equal(TwistVel, TwistVel, float eps=epsilon) -> bool\n"
    "Equal(Twist, TwistVel, float eps=epsilon) -> bool\n"
    "Equal(TwistVel, Twist, float eps=epsilon) -> bool\n"
    "Equal(JntSpaceInertiaMatrix, JntSpaceInertiaMatrix, float eps=epsilon) -> bool");

extern "C" {static PyObject *func_Equal(PyObject *,PyObject *);}
static PyObject *func_Equal(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Vector* a0;
        const Vector* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Rotation* a0;
        const Rotation* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Rotation, &a0, sipType_Rotation, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Frame* a0;
        const Frame* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Frame, &a0, sipType_Frame, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Twist* a0;
        const Twist* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Wrench* a0;
        const Wrench* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const JntArray* a0;
        const JntArray* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_JntArray, &a0, sipType_JntArray, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const JntArrayVel* a0;
        const JntArrayVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const doubleVel* a0;
        const doubleVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const VectorVel* a0;
        const VectorVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Vector* a0;
        const VectorVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Vector, &a0, sipType_VectorVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const VectorVel* a0;
        const Vector* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_VectorVel, &a0, sipType_Vector, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const RotationVel* a0;
        const RotationVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_RotationVel, &a0, sipType_RotationVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Rotation* a0;
        const RotationVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Rotation, &a0, sipType_RotationVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const RotationVel* a0;
        const Rotation* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_RotationVel, &a0, sipType_Rotation, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const FrameVel* a0;
        const FrameVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_FrameVel, &a0, sipType_FrameVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Frame* a0;
        const FrameVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Frame, &a0, sipType_FrameVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const FrameVel* a0;
        const Frame* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_FrameVel, &a0, sipType_Frame, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const TwistVel* a0;
        const TwistVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_TwistVel, &a0, sipType_TwistVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const Twist* a0;
        const TwistVel* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_Twist, &a0, sipType_TwistVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const TwistVel* a0;
        const Twist* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_TwistVel, &a0, sipType_Twist, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;
        const JntSpaceInertiaMatrix* a1;
        double a2 = epsilon;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9|d", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Equal, doc_Equal);

    return NULL;
}


PyDoc_STRVAR(doc_dot, "dot(Vector, Vector) -> float\n"
    "dot(Twist, Wrench) -> float\n"
    "dot(Wrench, Twist) -> float\n"
    "dot(VectorVel, VectorVel) -> doubleVel\n"
    "dot(VectorVel, Vector) -> doubleVel\n"
    "dot(Vector, VectorVel) -> doubleVel");

extern "C" {static PyObject *func_dot(PyObject *,PyObject *);}
static PyObject *func_dot(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Vector* a0;
        const Vector* a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const Twist* a0;
        const Wrench* a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_Twist, &a0, sipType_Wrench, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const Wrench* a0;
        const Twist* a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_Wrench, &a0, sipType_Twist, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const VectorVel* a0;
        const VectorVel* a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
            doubleVel*sipRes;

            sipRes = new doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const VectorVel* a0;
        const Vector* a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_VectorVel, &a0, sipType_Vector, &a1))
        {
            doubleVel*sipRes;

            sipRes = new doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const Vector* a0;
        const VectorVel* a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9J9", sipType_Vector, &a0, sipType_VectorVel, &a1))
        {
            doubleVel*sipRes;

            sipRes = new doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_dot, doc_dot);

    return NULL;
}


PyDoc_STRVAR(doc_SetToZero, "SetToZero(Vector)\n"
    "SetToZero(Twist)\n"
    "SetToZero(Wrench)\n"
    "SetToZero(JntArray)\n"
    "SetToZero(JntArrayVel)\n"
    "SetToZero(Jacobian)\n"
    "SetToZero(TwistVel)\n"
    "SetToZero(JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_SetToZero(PyObject *,PyObject *);}
static PyObject *func_SetToZero(PyObject *,PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        Vector* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Vector, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        Twist* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Twist, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        Wrench* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Wrench, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        JntArray* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_JntArray, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        JntArrayVel* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_JntArrayVel, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        Jacobian* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_Jacobian, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_TwistVel, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArgs, "J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_SetToZero, doc_SetToZero);

    return NULL;
}
static sipEnumTypeDef enumTypes[] = {
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_Joint__JointType, {0}}, sipNameNr_JointType, 22, NULL},
};


/*
 * This defines each type in this module.
 */
static sipTypeDef *typesTable[] = {
    &sipTypeDef_PyKDL_Chain.ctd_base,
    &sipTypeDef_PyKDL_ChainDynParam.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverPos.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverPos_recursive.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverVel.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverVel_recursive.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_LMA.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_NR.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv_givens.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_wdls.ctd_base,
    &sipTypeDef_PyKDL_ChainJntToJacSolver.ctd_base,
    &sipTypeDef_PyKDL_Frame.ctd_base,
    &sipTypeDef_PyKDL_FrameVel.ctd_base,
    &sipTypeDef_PyKDL_Jacobian.ctd_base,
    &sipTypeDef_PyKDL_JntArray.ctd_base,
    &sipTypeDef_PyKDL_JntArrayVel.ctd_base,
    &sipTypeDef_PyKDL_JntSpaceInertiaMatrix.ctd_base,
    &sipTypeDef_PyKDL_Joint.ctd_base,
    &enumTypes[0].etd_base,
    &sipTypeDef_PyKDL_RigidBodyInertia.ctd_base,
    &sipTypeDef_PyKDL_Rotation.ctd_base,
    &sipTypeDef_PyKDL_RotationVel.ctd_base,
    &sipTypeDef_PyKDL_RotationalInertia.ctd_base,
    &sipTypeDef_PyKDL_Segment.ctd_base,
    &sipTypeDef_PyKDL_Tree.ctd_base,
    &sipTypeDef_PyKDL_Twist.ctd_base,
    &sipTypeDef_PyKDL_TwistVel.ctd_base,
    &sipTypeDef_PyKDL_Vector.ctd_base,
    &sipTypeDef_PyKDL_VectorVel.ctd_base,
    &sipTypeDef_PyKDL_Wrench.ctd_base,
    &sipTypeDef_PyKDL_doubleVel.ctd_base,
    &sipTypeDef_PyKDL_std_string.mtd_base,
};


/*
 * These define each typedef in this module.
 */
static sipTypedefDef typedefsTable[] = {
    {"doubleVel::doubleVel", "Rall1d<double>"},
};


/*
 * This defines the virtual handlers that this module implements and can be
 * used by other modules.
 */
static sipVirtHandlerFunc virtHandlersTable[] = {
    (sipVirtHandlerFunc)sipVH_PyKDL_0,
    (sipVirtHandlerFunc)sipVH_PyKDL_1,
    (sipVirtHandlerFunc)sipVH_PyKDL_2,
    (sipVirtHandlerFunc)sipVH_PyKDL_3,
    (sipVirtHandlerFunc)sipVH_PyKDL_4,
};


/* Define the module's license. */
static sipLicenseDef module_license = {
    "LGPL",
    "Ruben Smits",
    "2014",
    "ruben@intermodalics.eu"
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_PyKDL = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_PyKDL,
    0,
    0,
    sipStrings_PyKDL,
    NULL,
    NULL,
    37,
    typesTable,
    NULL,
    0,
    NULL,
    1,
    typedefsTable,
    virtHandlersTable,
    NULL,
    NULL,
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    &module_license,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_PyKDL;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit_PyKDL
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        initPyKDL
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_MLNAME_CAST(sipName_changeRefFrame), func_changeRefFrame, METH_VARARGS, SIP_MLDOC_CAST(doc_changeRefFrame)},
        {SIP_MLNAME_CAST(sipName_changeBase), func_changeBase, METH_VARARGS, SIP_MLDOC_CAST(doc_changeBase)},
        {SIP_MLNAME_CAST(sipName_changeRefPoint), func_changeRefPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_changeRefPoint)},
        {SIP_MLNAME_CAST(sipName_MultiplyJacobian), func_MultiplyJacobian, METH_VARARGS, SIP_MLDOC_CAST(doc_MultiplyJacobian)},
        {SIP_MLNAME_CAST(sipName_Divide), func_Divide, METH_VARARGS, SIP_MLDOC_CAST(doc_Divide)},
        {SIP_MLNAME_CAST(sipName_Multiply), func_Multiply, METH_VARARGS, SIP_MLDOC_CAST(doc_Multiply)},
        {SIP_MLNAME_CAST(sipName_Subtract), func_Subtract, METH_VARARGS, SIP_MLDOC_CAST(doc_Subtract)},
        {SIP_MLNAME_CAST(sipName_Add), func_Add, METH_VARARGS, SIP_MLDOC_CAST(doc_Add)},
        {SIP_MLNAME_CAST(sipName_addDelta), func_addDelta, METH_VARARGS, SIP_MLDOC_CAST(doc_addDelta)},
        {SIP_MLNAME_CAST(sipName_diff), func_diff, METH_VARARGS, SIP_MLDOC_CAST(doc_diff)},
        {SIP_MLNAME_CAST(sipName_Equal), func_Equal, METH_VARARGS, SIP_MLDOC_CAST(doc_Equal)},
        {SIP_MLNAME_CAST(sipName_dot), func_dot, METH_VARARGS, SIP_MLDOC_CAST(doc_dot)},
        {SIP_MLNAME_CAST(sipName_SetToZero), func_SetToZero, METH_VARARGS, SIP_MLDOC_CAST(doc_SetToZero)},
        {0, 0, 0, 0}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "PyKDL",
        NULL,
        -1,
        sip_methods,
        NULL,
        NULL,
        NULL,
        NULL
    };
#endif

    PyObject *sipModule, *sipModuleDict;
    PyObject *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_PyKDL, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_PyKDL), sip_methods);
#endif

    if (sipModule == NULL)
        SIP_MODULE_RETURN(NULL);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Get the SIP module's API. */
#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule(SIP_MODULE_NAME);
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>(SIP_MODULE_NAME));
#endif

    if (sip_sipmod == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");
    Py_DECREF(sip_sipmod);

#if defined(SIP_USE_PYCAPSULE)
    if (sip_capiobj == NULL || !PyCapsule_CheckExact(sip_capiobj))
#else
    if (sip_capiobj == NULL || !PyCObject_Check(sip_capiobj))
#endif
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

#if defined(SIP_USE_PYCAPSULE)
    sipAPI_PyKDL = reinterpret_cast<const sipAPIDef *>(PyCapsule_GetPointer(sip_capiobj, SIP_MODULE_NAME "._C_API"));
#else
    sipAPI_PyKDL = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));
#endif

#if defined(SIP_USE_PYCAPSULE)
    if (sipAPI_PyKDL == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }
#endif

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI_PyKDL,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }
    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI_PyKDL,sipModuleDict) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }

    SIP_MODULE_RETURN(sipModule);
}

#line 65 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/chaindynparam.hpp>
using namespace KDL;
#line 1832 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

#line 133 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1837 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1843 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 172 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1847 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 1851 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_ChainDynParam_JntToCoriolis, "ChainDynParam.JntToCoriolis(JntArray, JntArray, JntArray) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToCoriolis(PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToCoriolis(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        const JntArray* a1;
        JntArray* a2;
        ChainDynParam *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = sipCpp->JntToCoriolis(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToCoriolis, doc_ChainDynParam_JntToCoriolis);

    return NULL;
}


PyDoc_STRVAR(doc_ChainDynParam_JntToMass, "ChainDynParam.JntToMass(JntArray, JntSpaceInertiaMatrix) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToMass(PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToMass(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        JntSpaceInertiaMatrix* a1;
        ChainDynParam *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntSpaceInertiaMatrix, &a1))
        {
            int sipRes;

            sipRes = sipCpp->JntToMass(*a0,*a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToMass, doc_ChainDynParam_JntToMass);

    return NULL;
}


PyDoc_STRVAR(doc_ChainDynParam_JntToGravity, "ChainDynParam.JntToGravity(JntArray, JntArray) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToGravity(PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToGravity(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntArray* a0;
        JntArray* a1;
        ChainDynParam *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1))
        {
            int sipRes;

            sipRes = sipCpp->JntToGravity(*a0,*a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToGravity, doc_ChainDynParam_JntToGravity);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_ChainDynParam(void *, const sipTypeDef *);}
static void *cast_ChainDynParam(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_ChainDynParam)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainDynParam(void *, int);}
static void release_ChainDynParam(void *sipCppV,int)
{
    delete reinterpret_cast<ChainDynParam *>(sipCppV);
}


extern "C" {static void dealloc_ChainDynParam(sipSimpleWrapper *);}
static void dealloc_ChainDynParam(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_ChainDynParam(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_ChainDynParam(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainDynParam(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    ChainDynParam *sipCpp = 0;

    {
        const Chain* a0;
        Vector* a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9J9", sipType_Chain, &a0, sipType_Vector, &a1))
        {
            sipCpp = new ChainDynParam(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const ChainDynParam* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainDynParam, &a0))
        {
            sipCpp = new ChainDynParam(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_ChainDynParam[] = {
    {SIP_MLNAME_CAST(sipName_JntToCoriolis), meth_ChainDynParam_JntToCoriolis, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToCoriolis)},
    {SIP_MLNAME_CAST(sipName_JntToGravity), meth_ChainDynParam_JntToGravity, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToGravity)},
    {SIP_MLNAME_CAST(sipName_JntToMass), meth_ChainDynParam_JntToMass, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToMass)}
};

PyDoc_STRVAR(doc_ChainDynParam, "\1ChainDynParam(Chain, Vector)\n"
    "ChainDynParam(ChainDynParam)");


sipClassTypeDef sipTypeDef_PyKDL_ChainDynParam = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainDynParam,
        {0}
    },
    {
        sipNameNr_ChainDynParam,
        {0, 0, 1},
        3, methods_ChainDynParam,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainDynParam,
    -1,
    -1,
    0,
    0,
    init_type_ChainDynParam,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainDynParam,
    0,
    0,
    0,
    release_ChainDynParam,
    cast_ChainDynParam,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 2065 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"



PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_resize, "JntSpaceInertiaMatrix.resize(int)");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_resize(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_resize(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bu", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_resize, doc_JntSpaceInertiaMatrix_resize);

    return NULL;
}


PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_rows, "JntSpaceInertiaMatrix.rows() -> int");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_rows(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_rows, doc_JntSpaceInertiaMatrix_rows);

    return NULL;
}


PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_columns, "JntSpaceInertiaMatrix.columns() -> int");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_columns(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_columns, doc_JntSpaceInertiaMatrix_columns);

    return NULL;
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___ne__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___ne__(PyObject *sipSelf,PyObject *sipArg)
{
    JntSpaceInertiaMatrix *sipCpp = reinterpret_cast<JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            bool sipRes;

            sipRes = !operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,ne_slot,sipType_JntSpaceInertiaMatrix,sipSelf,sipArg);
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___eq__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___eq__(PyObject *sipSelf,PyObject *sipArg)
{
    JntSpaceInertiaMatrix *sipCpp = reinterpret_cast<JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,eq_slot,sipType_JntSpaceInertiaMatrix,sipSelf,sipArg);
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___getitem__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
    JntSpaceInertiaMatrix *sipCpp = reinterpret_cast<JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1T", &PyTuple_Type, &a0))
        {
            double sipRes = 0;

#line 39 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > (int)sipCpp->rows() || j >= (int)sipCpp->columns()) {
        PyErr_SetString(PyExc_IndexError, "Inertia index out of range");
        return NULL;
    }
    sipRes=(*sipCpp)(i,j);
#line 2239 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName___getitem__, NULL);

    return 0;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_JntSpaceInertiaMatrix(void *, const sipTypeDef *);}
static void *cast_JntSpaceInertiaMatrix(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_JntSpaceInertiaMatrix)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntSpaceInertiaMatrix(void *, int);}
static void release_JntSpaceInertiaMatrix(void *sipCppV,int)
{
    delete reinterpret_cast<JntSpaceInertiaMatrix *>(sipCppV);
}


extern "C" {static void assign_JntSpaceInertiaMatrix(void *, SIP_SSIZE_T, const void *);}
static void assign_JntSpaceInertiaMatrix(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<JntSpaceInertiaMatrix *>(sipDst)[sipDstIdx] = *reinterpret_cast<const JntSpaceInertiaMatrix *>(sipSrc);
}


extern "C" {static void *array_JntSpaceInertiaMatrix(SIP_SSIZE_T);}
static void *array_JntSpaceInertiaMatrix(SIP_SSIZE_T sipNrElem)
{
    return new JntSpaceInertiaMatrix[sipNrElem];
}


extern "C" {static void *copy_JntSpaceInertiaMatrix(const void *, SIP_SSIZE_T);}
static void *copy_JntSpaceInertiaMatrix(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new JntSpaceInertiaMatrix(reinterpret_cast<const JntSpaceInertiaMatrix *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_JntSpaceInertiaMatrix(sipSimpleWrapper *);}
static void dealloc_JntSpaceInertiaMatrix(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_JntSpaceInertiaMatrix(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_JntSpaceInertiaMatrix(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntSpaceInertiaMatrix(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    JntSpaceInertiaMatrix *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new JntSpaceInertiaMatrix();

            return sipCpp;
        }
    }

    {
        int a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "i", &a0))
        {
            sipCpp = new JntSpaceInertiaMatrix(a0);

            return sipCpp;
        }
    }

    {
        const JntSpaceInertiaMatrix* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            sipCpp = new JntSpaceInertiaMatrix(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_JntSpaceInertiaMatrix[] = {
    {(void *)slot_JntSpaceInertiaMatrix___ne__, ne_slot},
    {(void *)slot_JntSpaceInertiaMatrix___eq__, eq_slot},
    {(void *)slot_JntSpaceInertiaMatrix___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_JntSpaceInertiaMatrix[] = {
    {SIP_MLNAME_CAST(sipName_columns), meth_JntSpaceInertiaMatrix_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_columns)},
    {SIP_MLNAME_CAST(sipName_resize), meth_JntSpaceInertiaMatrix_resize, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_JntSpaceInertiaMatrix_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_rows)}
};

PyDoc_STRVAR(doc_JntSpaceInertiaMatrix, "\1JntSpaceInertiaMatrix()\n"
    "JntSpaceInertiaMatrix(int)\n"
    "JntSpaceInertiaMatrix(JntSpaceInertiaMatrix)");


sipClassTypeDef sipTypeDef_PyKDL_JntSpaceInertiaMatrix = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntSpaceInertiaMatrix,
        {0}
    },
    {
        sipNameNr_JntSpaceInertiaMatrix,
        {0, 0, 1},
        3, methods_JntSpaceInertiaMatrix,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntSpaceInertiaMatrix,
    -1,
    -1,
    0,
    slots_JntSpaceInertiaMatrix,
    init_type_JntSpaceInertiaMatrix,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntSpaceInertiaMatrix,
    assign_JntSpaceInertiaMatrix,
    array_JntSpaceInertiaMatrix,
    copy_JntSpaceInertiaMatrix,
    release_JntSpaceInertiaMatrix,
    cast_JntSpaceInertiaMatrix,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 207 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 2414 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

#line 44 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 2419 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 281 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 2425 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 2429 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_TwistVel_value, "TwistVel.value() -> Twist");

extern "C" {static PyObject *meth_TwistVel_value(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_value, doc_TwistVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_deriv, "TwistVel.deriv() -> Twist");

extern "C" {static PyObject *meth_TwistVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_deriv, doc_TwistVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_Zero, "TwistVel.Zero() -> TwistVel");

extern "C" {static PyObject *meth_TwistVel_Zero(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel(TwistVel::Zero());

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_Zero, doc_TwistVel_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_ReverseSign, "TwistVel.ReverseSign()");

extern "C" {static PyObject *meth_TwistVel_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_ReverseSign, doc_TwistVel_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_RefPoint, "TwistVel.RefPoint(VectorVel) -> TwistVel");

extern "C" {static PyObject *meth_TwistVel_RefPoint(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_RefPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const VectorVel* a0;
        TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_TwistVel, &sipCpp, sipType_VectorVel, &a0))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_RefPoint, doc_TwistVel_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_GetTwist, "TwistVel.GetTwist() -> Twist");

extern "C" {static PyObject *meth_TwistVel_GetTwist(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_GetTwist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->GetTwist());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_GetTwist, doc_TwistVel_GetTwist);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_GetTwistDot, "TwistVel.GetTwistDot() -> Twist");

extern "C" {static PyObject *meth_TwistVel_GetTwistDot(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_GetTwistDot(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->GetTwistDot());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_GetTwistDot, doc_TwistVel_GetTwistDot);

    return NULL;
}


extern "C" {static PyObject *slot_TwistVel___neg__(PyObject *);}
static PyObject *slot_TwistVel___neg__(PyObject *sipSelf)
{
    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;


    {
        {
            TwistVel*sipRes;

            sipRes = new TwistVel(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_TwistVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_TwistVel, &a0, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        double a0;
        const TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_TwistVel, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const TwistVel* a0;
        const doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_doubleVel, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,mul_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___div__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_TwistVel, &a0, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const TwistVel* a0;
        const doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_doubleVel, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 / *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,div_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___add__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel* a0;
        const TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_TwistVel, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,add_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___sub__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const TwistVel* a0;
        const TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_TwistVel, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,sub_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___iadd__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_TwistVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_TwistVel, &a0))
        {
            sipCpp->TwistVel::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_TwistVel___isub__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_TwistVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_TwistVel, &a0))
        {
            sipCpp->TwistVel::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_TwistVel(void *, const sipTypeDef *);}
static void *cast_TwistVel(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_TwistVel)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_TwistVel(void *, int);}
static void release_TwistVel(void *sipCppV,int)
{
    delete reinterpret_cast<TwistVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_TwistVel(void *);}
static PyObject *pickle_TwistVel(void *sipCppV)
{
    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipCppV);
    PyObject *sipRes;

#line 233 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vectorvel_type = sipFindType("VectorVel");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->vel), vectorvel_type, Py_None),
                                 sipConvertFromType(&(sipCpp->rot), vectorvel_type, Py_None));
#line 2905 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_TwistVel(void *, SIP_SSIZE_T, const void *);}
static void assign_TwistVel(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<TwistVel *>(sipDst)[sipDstIdx] = *reinterpret_cast<const TwistVel *>(sipSrc);
}


extern "C" {static void *array_TwistVel(SIP_SSIZE_T);}
static void *array_TwistVel(SIP_SSIZE_T sipNrElem)
{
    return new TwistVel[sipNrElem];
}


extern "C" {static void *copy_TwistVel(const void *, SIP_SSIZE_T);}
static void *copy_TwistVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new TwistVel(reinterpret_cast<const TwistVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_TwistVel(sipSimpleWrapper *);}
static void dealloc_TwistVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_TwistVel(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_TwistVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_TwistVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    TwistVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new TwistVel();

            return sipCpp;
        }
    }

    {
        const VectorVel* a0;
        const VectorVel* a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
            sipCpp = new TwistVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const Twist* a0;
        const Twist* a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9J9", sipType_Twist, &a0, sipType_Twist, &a1))
        {
            sipCpp = new TwistVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const Twist* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Twist, &a0))
        {
            sipCpp = new TwistVel(*a0);

            return sipCpp;
        }
    }

    {
        const TwistVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_TwistVel, &a0))
        {
            sipCpp = new TwistVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_TwistVel[] = {
    {(void *)slot_TwistVel___neg__, neg_slot},
    {(void *)slot_TwistVel___mul__, mul_slot},
    {(void *)slot_TwistVel___div__, div_slot},
    {(void *)slot_TwistVel___add__, add_slot},
    {(void *)slot_TwistVel___sub__, sub_slot},
    {(void *)slot_TwistVel___iadd__, iadd_slot},
    {(void *)slot_TwistVel___isub__, isub_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_TwistVel[] = {
    {SIP_MLNAME_CAST(sipName_GetTwist), meth_TwistVel_GetTwist, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_GetTwist)},
    {SIP_MLNAME_CAST(sipName_GetTwistDot), meth_TwistVel_GetTwistDot, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_GetTwistDot)},
    {SIP_MLNAME_CAST(sipName_RefPoint), meth_TwistVel_RefPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_RefPoint)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_TwistVel_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_TwistVel_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_Zero)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_TwistVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_TwistVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_value)}
};


extern "C" {static PyObject *varget_TwistVel_rot(void *, PyObject *, PyObject *);}
static PyObject *varget_TwistVel_rot(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
    VectorVel*sipVal;
    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -1);
    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->rot;

    sipPy = sipConvertFromType(sipVal, sipType_VectorVel, NULL);
    sipKeepReference(sipPySelf, -1, sipPy);

    return sipPy;
}


extern "C" {static int varset_TwistVel_rot(void *, PyObject *, PyObject *);}
static int varset_TwistVel_rot(void *sipSelf, PyObject *sipPy, PyObject *)
{
    VectorVel*sipVal;
    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->rot = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_TwistVel_vel(void *, PyObject *, PyObject *);}
static PyObject *varget_TwistVel_vel(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
    VectorVel*sipVal;
    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -2);
    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->vel;

    sipPy = sipConvertFromType(sipVal, sipType_VectorVel, NULL);
    sipKeepReference(sipPySelf, -2, sipPy);

    return sipPy;
}


extern "C" {static int varset_TwistVel_vel(void *, PyObject *, PyObject *);}
static int varset_TwistVel_vel(void *sipSelf, PyObject *sipPy, PyObject *)
{
    VectorVel*sipVal;
    TwistVel *sipCpp = reinterpret_cast<TwistVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->vel = *sipVal;

    return 0;
}

sipVariableDef variables_TwistVel[] = {
    {InstanceVariable, sipName_rot, (PyMethodDef *)varget_TwistVel_rot, (PyMethodDef *)varset_TwistVel_rot, NULL, NULL},
    {InstanceVariable, sipName_vel, (PyMethodDef *)varget_TwistVel_vel, (PyMethodDef *)varset_TwistVel_vel, NULL, NULL},
};

PyDoc_STRVAR(doc_TwistVel, "\1TwistVel()\n"
    "TwistVel(VectorVel, VectorVel)\n"
    "TwistVel(Twist, Twist)\n"
    "TwistVel(Twist)\n"
    "TwistVel(TwistVel)");


sipClassTypeDef sipTypeDef_PyKDL_TwistVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_TwistVel,
        {0}
    },
    {
        sipNameNr_TwistVel,
        {0, 0, 1},
        7, methods_TwistVel,
        0, 0,
        2, variables_TwistVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_TwistVel,
    -1,
    -1,
    0,
    slots_TwistVel,
    init_type_TwistVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_TwistVel,
    assign_TwistVel,
    array_TwistVel,
    copy_TwistVel,
    release_TwistVel,
    cast_TwistVel,
    0,
    0,
    0,
    pickle_TwistVel,
    0,
    0
};

#line 159 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3171 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

#line 100 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3176 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 44 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3180 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 201 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 3186 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 281 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 3192 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 3198 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"
#line 207 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3202 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_FrameVel_value, "FrameVel.value() -> Frame");

extern "C" {static PyObject *meth_FrameVel_value(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
            Frame*sipRes;

            sipRes = new Frame(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_value, doc_FrameVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_deriv, "FrameVel.deriv() -> Twist");

extern "C" {static PyObject *meth_FrameVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_deriv, doc_FrameVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_Identity, "FrameVel.Identity() -> FrameVel");

extern "C" {static PyObject *meth_FrameVel_Identity(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_Identity(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            FrameVel*sipRes;

            sipRes = new FrameVel(FrameVel::Identity());

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_Identity, doc_FrameVel_Identity);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_Inverse, "FrameVel.Inverse() -> FrameVel\n"
    "FrameVel.Inverse(VectorVel) -> VectorVel\n"
    "FrameVel.Inverse(Vector) -> VectorVel\n"
    "FrameVel.Inverse(TwistVel) -> TwistVel\n"
    "FrameVel.Inverse(Twist) -> TwistVel");

extern "C" {static PyObject *meth_FrameVel_Inverse(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_Inverse(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
            FrameVel*sipRes;

            sipRes = new FrameVel(sipCpp->Inverse());

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    {
        const VectorVel* a0;
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_VectorVel, &a0))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const Vector* a0;
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_Vector, &a0))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const TwistVel* a0;
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_TwistVel, &a0))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const Twist* a0;
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_Twist, &a0))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_Inverse, doc_FrameVel_Inverse);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_GetFrame, "FrameVel.GetFrame() -> Frame");

extern "C" {static PyObject *meth_FrameVel_GetFrame(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_GetFrame(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
            Frame*sipRes;

            sipRes = new Frame(sipCpp->GetFrame());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_GetFrame, doc_FrameVel_GetFrame);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_GetTwist, "FrameVel.GetTwist() -> Twist");

extern "C" {static PyObject *meth_FrameVel_GetTwist(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_GetTwist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->GetTwist());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_GetTwist, doc_FrameVel_GetTwist);

    return NULL;
}


extern "C" {static PyObject *slot_FrameVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_FrameVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        FrameVel* a0;
        const VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_VectorVel, &a1))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        FrameVel* a0;
        const Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Vector, &a1))
        {
            VectorVel*sipRes;

            sipRes = new VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        FrameVel* a0;
        const TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_TwistVel, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        FrameVel* a0;
        const Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Twist, &a1))
        {
            TwistVel*sipRes;

            sipRes = new TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const FrameVel* a0;
        const FrameVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_FrameVel, &a1))
        {
            FrameVel*sipRes;

            sipRes = new FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    {
        const FrameVel* a0;
        const Frame* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Frame, &a1))
        {
            FrameVel*sipRes;

            sipRes = new FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,mul_slot,NULL,sipArg0,sipArg1);
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_FrameVel(void *, const sipTypeDef *);}
static void *cast_FrameVel(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_FrameVel)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_FrameVel(void *, int);}
static void release_FrameVel(void *sipCppV,int)
{
    delete reinterpret_cast<FrameVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_FrameVel(void *);}
static PyObject *pickle_FrameVel(void *sipCppV)
{
    FrameVel *sipCpp = reinterpret_cast<FrameVel *>(sipCppV);
    PyObject *sipRes;

#line 191 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vectorvel_type = sipFindType("VectorVel");
    const sipTypeDef *rotationvel_type = sipFindType("RotationVel");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->M), rotationvel_type, Py_None),
                                 sipConvertFromType(&(sipCpp->p), vectorvel_type, Py_None));
#line 3553 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_FrameVel(void *, SIP_SSIZE_T, const void *);}
static void assign_FrameVel(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<FrameVel *>(sipDst)[sipDstIdx] = *reinterpret_cast<const FrameVel *>(sipSrc);
}


extern "C" {static void *array_FrameVel(SIP_SSIZE_T);}
static void *array_FrameVel(SIP_SSIZE_T sipNrElem)
{
    return new FrameVel[sipNrElem];
}


extern "C" {static void *copy_FrameVel(const void *, SIP_SSIZE_T);}
static void *copy_FrameVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new FrameVel(reinterpret_cast<const FrameVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_FrameVel(sipSimpleWrapper *);}
static void dealloc_FrameVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_FrameVel(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_FrameVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_FrameVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    FrameVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new FrameVel();

            return sipCpp;
        }
    }

    {
        const Frame* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Frame, &a0))
        {
            sipCpp = new FrameVel(*a0);

            return sipCpp;
        }
    }

    {
        const Frame* a0;
        const Twist* a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9J9", sipType_Frame, &a0, sipType_Twist, &a1))
        {
            sipCpp = new FrameVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const RotationVel* a0;
        const VectorVel* a1;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9J9", sipType_RotationVel, &a0, sipType_VectorVel, &a1))
        {
            sipCpp = new FrameVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const FrameVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_FrameVel, &a0))
        {
            sipCpp = new FrameVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_FrameVel[] = {
    {(void *)slot_FrameVel___mul__, mul_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_FrameVel[] = {
    {SIP_MLNAME_CAST(sipName_GetFrame), meth_FrameVel_GetFrame, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_GetFrame)},
    {SIP_MLNAME_CAST(sipName_GetTwist), meth_FrameVel_GetTwist, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_GetTwist)},
    {SIP_MLNAME_CAST(sipName_Identity), meth_FrameVel_Identity, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_Identity)},
    {SIP_MLNAME_CAST(sipName_Inverse), meth_FrameVel_Inverse, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_Inverse)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_FrameVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_FrameVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_value)}
};


extern "C" {static PyObject *varget_FrameVel_M(void *, PyObject *, PyObject *);}
static PyObject *varget_FrameVel_M(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
    RotationVel*sipVal;
    FrameVel *sipCpp = reinterpret_cast<FrameVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -3);
    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->M;

    sipPy = sipConvertFromType(sipVal, sipType_RotationVel, NULL);
    sipKeepReference(sipPySelf, -3, sipPy);

    return sipPy;
}


extern "C" {static int varset_FrameVel_M(void *, PyObject *, PyObject *);}
static int varset_FrameVel_M(void *sipSelf, PyObject *sipPy, PyObject *)
{
    RotationVel*sipVal;
    FrameVel *sipCpp = reinterpret_cast<FrameVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<RotationVel *>(sipForceConvertToType(sipPy,sipType_RotationVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->M = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_FrameVel_p(void *, PyObject *, PyObject *);}
static PyObject *varget_FrameVel_p(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
    VectorVel*sipVal;
    FrameVel *sipCpp = reinterpret_cast<FrameVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -4);
    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->p;

    sipPy = sipConvertFromType(sipVal, sipType_VectorVel, NULL);
    sipKeepReference(sipPySelf, -4, sipPy);

    return sipPy;
}


extern "C" {static int varset_FrameVel_p(void *, PyObject *, PyObject *);}
static int varset_FrameVel_p(void *sipSelf, PyObject *sipPy, PyObject *)
{
    VectorVel*sipVal;
    FrameVel *sipCpp = reinterpret_cast<FrameVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast<VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->p = *sipVal;

    return 0;
}

sipVariableDef variables_FrameVel[] = {
    {InstanceVariable, sipName_M, (PyMethodDef *)varget_FrameVel_M, (PyMethodDef *)varset_FrameVel_M, NULL, NULL},
    {InstanceVariable, sipName_p, (PyMethodDef *)varget_FrameVel_p, (PyMethodDef *)varset_FrameVel_p, NULL, NULL},
};

PyDoc_STRVAR(doc_FrameVel, "\1FrameVel()\n"
    "FrameVel(Frame)\n"
    "FrameVel(Frame, Twist)\n"
    "FrameVel(RotationVel, VectorVel)\n"
    "FrameVel(FrameVel)");


sipClassTypeDef sipTypeDef_PyKDL_FrameVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_FrameVel,
        {0}
    },
    {
        sipNameNr_FrameVel,
        {0, 0, 1},
        6, methods_FrameVel,
        0, 0,
        2, variables_FrameVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_FrameVel,
    -1,
    -1,
    0,
    slots_FrameVel,
    init_type_FrameVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_FrameVel,
    assign_FrameVel,
    array_FrameVel,
    copy_FrameVel,
    release_FrameVel,
    cast_FrameVel,
    0,
    0,
    0,
    pickle_FrameVel,
    0,
    0
};
