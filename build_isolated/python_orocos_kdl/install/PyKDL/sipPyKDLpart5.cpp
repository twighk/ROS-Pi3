/*
 * Module code.
 *
 * Generated by SIP 4.17
 */

#include "sipAPIPyKDL.h"

#line 153 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 13 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 17 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 133 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 21 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 103 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 26 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Tree_addSegment, "Tree.addSegment(Segment, string) -> bool");

extern "C" {static PyObject *meth_Tree_addSegment(PyObject *, PyObject *);}
static PyObject *meth_Tree_addSegment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment* a0;
        const std::string* a1;
        int a1State = 0;
        Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9J1", &sipSelf, sipType_Tree, &sipCpp, sipType_Segment, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->addSegment(*a0,*a1);
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_addSegment, doc_Tree_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfJoints, "Tree.getNrOfJoints() -> int");

extern "C" {static PyObject *meth_Tree_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfJoints, doc_Tree_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfSegments, "Tree.getNrOfSegments() -> int");

extern "C" {static PyObject *meth_Tree_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfSegments, doc_Tree_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getChain, "Tree.getChain(string, string) -> Chain");

extern "C" {static PyObject *meth_Tree_getChain(PyObject *, PyObject *);}
static PyObject *meth_Tree_getChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const std::string* a0;
        int a0State = 0;
        const std::string* a1;
        int a1State = 0;
        const Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1J1", &sipSelf, sipType_Tree, &sipCpp, sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State))
        {
            Chain*sipRes = 0;

#line 163 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    Chain* chain = new Chain();
    sipCpp->getChain(*a0, *a1, *chain);
    sipRes = chain;
#line 136 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);
            sipReleaseType(const_cast<std::string *>(a1),sipType_std_string,a1State);

            return sipConvertFromType(sipRes,sipType_Chain,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getChain, doc_Tree_getChain);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_Tree(void *, const sipTypeDef *);}
static void *cast_Tree(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_Tree)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Tree(void *, int);}
static void release_Tree(void *sipCppV,int)
{
    delete reinterpret_cast<Tree *>(sipCppV);
}


extern "C" {static void assign_Tree(void *, SIP_SSIZE_T, const void *);}
static void assign_Tree(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<Tree *>(sipDst)[sipDstIdx] = *reinterpret_cast<const Tree *>(sipSrc);
}


extern "C" {static void *array_Tree(SIP_SSIZE_T);}
static void *array_Tree(SIP_SSIZE_T sipNrElem)
{
    return new Tree[sipNrElem];
}


extern "C" {static void *copy_Tree(const void *, SIP_SSIZE_T);}
static void *copy_Tree(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new Tree(reinterpret_cast<const Tree *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Tree(sipSimpleWrapper *);}
static void dealloc_Tree(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_Tree(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_Tree(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Tree(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    Tree *sipCpp = 0;

    {
        const std::string& a0def = "root";
        const std::string* a0 = &a0def;
        int a0State = 0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "|J1", sipType_std_string,&a0, &a0State))
        {
            sipCpp = new Tree(*a0);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const Tree* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Tree, &a0))
        {
            sipCpp = new Tree(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Tree[] = {
    {SIP_MLNAME_CAST(sipName_addSegment), meth_Tree_addSegment, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_addSegment)},
    {SIP_MLNAME_CAST(sipName_getChain), meth_Tree_getChain, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getChain)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Tree_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Tree_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfSegments)}
};

PyDoc_STRVAR(doc_Tree, "\1Tree(string root_name=\"root\")\n"
    "Tree(Tree)");


sipClassTypeDef sipTypeDef_PyKDL_Tree = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Tree,
        {0}
    },
    {
        sipNameNr_Tree,
        {0, 0, 1},
        4, methods_Tree,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Tree,
    -1,
    -1,
    0,
    0,
    init_type_Tree,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Tree,
    assign_Tree,
    array_Tree,
    copy_Tree,
    release_Tree,
    cast_Tree,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 133 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 298 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"

#line 103 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 304 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Chain_addSegment, "Chain.addSegment(Segment)");

extern "C" {static PyObject *meth_Chain_addSegment(PyObject *, PyObject *);}
static PyObject *meth_Chain_addSegment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment* a0;
        Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Segment, &a0))
        {
            sipCpp->addSegment(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addSegment, doc_Chain_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_addChain, "Chain.addChain(Chain)");

extern "C" {static PyObject *meth_Chain_addChain(PyObject *, PyObject *);}
static PyObject *meth_Chain_addChain(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Chain* a0;
        Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Chain, &a0))
        {
            sipCpp->addChain(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addChain, doc_Chain_addChain);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfJoints, "Chain.getNrOfJoints() -> int");

extern "C" {static PyObject *meth_Chain_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfJoints, doc_Chain_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfSegments, "Chain.getNrOfSegments() -> int");

extern "C" {static PyObject *meth_Chain_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfSegments, doc_Chain_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getSegment, "Chain.getSegment(int) -> Segment");

extern "C" {static PyObject *meth_Chain_getSegment(PyObject *, PyObject *);}
static PyObject *meth_Chain_getSegment(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bu", &sipSelf, sipType_Chain, &sipCpp, &a0))
        {
            Segment*sipRes;

            sipRes = new Segment(sipCpp->getSegment(a0));

            return sipConvertFromNewType(sipRes,sipType_Segment,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getSegment, doc_Chain_getSegment);

    return NULL;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_Chain(void *, const sipTypeDef *);}
static void *cast_Chain(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_Chain)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Chain(void *, int);}
static void release_Chain(void *sipCppV,int)
{
    delete reinterpret_cast<Chain *>(sipCppV);
}


extern "C" {static void assign_Chain(void *, SIP_SSIZE_T, const void *);}
static void assign_Chain(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<Chain *>(sipDst)[sipDstIdx] = *reinterpret_cast<const Chain *>(sipSrc);
}


extern "C" {static void *array_Chain(SIP_SSIZE_T);}
static void *array_Chain(SIP_SSIZE_T sipNrElem)
{
    return new Chain[sipNrElem];
}


extern "C" {static void *copy_Chain(const void *, SIP_SSIZE_T);}
static void *copy_Chain(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new Chain(reinterpret_cast<const Chain *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Chain(sipSimpleWrapper *);}
static void dealloc_Chain(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_Chain(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_Chain(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Chain(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    Chain *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new Chain();

            return sipCpp;
        }
    }

    {
        const Chain* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new Chain(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Chain[] = {
    {SIP_MLNAME_CAST(sipName_addChain), meth_Chain_addChain, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_addChain)},
    {SIP_MLNAME_CAST(sipName_addSegment), meth_Chain_addSegment, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_addSegment)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Chain_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Chain_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfSegments)},
    {SIP_MLNAME_CAST(sipName_getSegment), meth_Chain_getSegment, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getSegment)}
};

PyDoc_STRVAR(doc_Chain, "\1Chain()\n"
    "Chain(Chain)");


sipClassTypeDef sipTypeDef_PyKDL_Chain = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Chain,
        {0}
    },
    {
        sipNameNr_Chain,
        {0, 0, 1},
        5, methods_Chain,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Chain,
    -1,
    -1,
    0,
    0,
    init_type_Chain,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Chain,
    assign_Chain,
    array_Chain,
    copy_Chain,
    release_Chain,
    cast_Chain,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 103 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 587 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 591 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 25 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 596 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 201 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 602 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 81 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 607 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 613 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Segment_getFrameToTip, "Segment.getFrameToTip() -> Frame");

extern "C" {static PyObject *meth_Segment_getFrameToTip(PyObject *, PyObject *);}
static PyObject *meth_Segment_getFrameToTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            Frame*sipRes;

            sipRes = new Frame(sipCpp->getFrameToTip());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getFrameToTip, doc_Segment_getFrameToTip);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_pose, "Segment.pose(float) -> Frame");

extern "C" {static PyObject *meth_Segment_pose(PyObject *, PyObject *);}
static PyObject *meth_Segment_pose(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bd", &sipSelf, sipType_Segment, &sipCpp, &a0))
        {
            Frame*sipRes;

            sipRes = new Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_pose, doc_Segment_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_twist, "Segment.twist(float, float) -> Twist");

extern "C" {static PyObject *meth_Segment_twist(PyObject *, PyObject *);}
static PyObject *meth_Segment_twist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bdd", &sipSelf, sipType_Segment, &sipCpp, &a0, &a1))
        {
            Twist*sipRes;

            sipRes = new Twist(sipCpp->twist(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_twist, doc_Segment_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getName, "Segment.getName() -> string");

extern "C" {static PyObject *meth_Segment_getName(PyObject *, PyObject *);}
static PyObject *meth_Segment_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            std::string*sipRes;

            sipRes = new std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getName, doc_Segment_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getJoint, "Segment.getJoint() -> Joint");

extern "C" {static PyObject *meth_Segment_getJoint(PyObject *, PyObject *);}
static PyObject *meth_Segment_getJoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            Joint*sipRes;

            sipRes = new Joint(sipCpp->getJoint());

            return sipConvertFromNewType(sipRes,sipType_Joint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getJoint, doc_Segment_getJoint);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getInertia, "Segment.getInertia() -> RigidBodyInertia");

extern "C" {static PyObject *meth_Segment_getInertia(PyObject *, PyObject *);}
static PyObject *meth_Segment_getInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia(sipCpp->getInertia());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getInertia, doc_Segment_getInertia);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_setInertia, "Segment.setInertia(RigidBodyInertia)");

extern "C" {static PyObject *meth_Segment_setInertia(PyObject *, PyObject *);}
static PyObject *meth_Segment_setInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia* a0;
        Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_Segment, &sipCpp, sipType_RigidBodyInertia, &a0))
        {
            sipCpp->setInertia(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_setInertia, doc_Segment_setInertia);

    return NULL;
}


extern "C" {static PyObject *slot_Segment___repr__(PyObject *);}
static PyObject *slot_Segment___repr__(PyObject *sipSelf)
{
    Segment *sipCpp = reinterpret_cast<Segment *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Segment));

    if (!sipCpp)
        return 0;


    {
        {
            const char*sipRes = 0;

#line 114 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<(*sipCpp);
    std::string s(ss.str());
    sipRes=s.c_str();
#line 826 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"

            if (sipRes == NULL)
            {
                Py_INCREF(Py_None);
                return Py_None;
            }

            return SIPBytes_FromString(sipRes);
        }
    }

    return 0;
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_Segment(void *, const sipTypeDef *);}
static void *cast_Segment(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_Segment)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Segment(void *, int);}
static void release_Segment(void *sipCppV,int)
{
    delete reinterpret_cast<Segment *>(sipCppV);
}


extern "C" {static void assign_Segment(void *, SIP_SSIZE_T, const void *);}
static void assign_Segment(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<Segment *>(sipDst)[sipDstIdx] = *reinterpret_cast<const Segment *>(sipSrc);
}


extern "C" {static void *array_Segment(SIP_SSIZE_T);}
static void *array_Segment(SIP_SSIZE_T sipNrElem)
{
    return new Segment[sipNrElem];
}


extern "C" {static void *copy_Segment(const void *, SIP_SSIZE_T);}
static void *copy_Segment(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new Segment(reinterpret_cast<const Segment *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Segment(sipSimpleWrapper *);}
static void dealloc_Segment(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_Segment(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_Segment(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Segment(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    Segment *sipCpp = 0;

    {
        const std::string* a0;
        int a0State = 0;
        const Joint& a1def = Joint(Joint::None);
        const Joint* a1 = &a1def;
        const Frame& a2def = Frame::Identity();
        const Frame* a2 = &a2def;
        const RigidBodyInertia& a3def = RigidBodyInertia::Zero();
        const RigidBodyInertia* a3 = &a3def;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J1|J9J9J9", sipType_std_string,&a0, &a0State, sipType_Joint, &a1, sipType_Frame, &a2, sipType_RigidBodyInertia, &a3))
        {
            sipCpp = new Segment(*a0,*a1,*a2,*a3);
            sipReleaseType(const_cast<std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const Joint& a0def = Joint(Joint::None);
        const Joint* a0 = &a0def;
        const Frame& a1def = Frame::Identity();
        const Frame* a1 = &a1def;
        const RigidBodyInertia& a2def = RigidBodyInertia::Zero();
        const RigidBodyInertia* a2 = &a2def;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "|J9J9J9", sipType_Joint, &a0, sipType_Frame, &a1, sipType_RigidBodyInertia, &a2))
        {
            sipCpp = new Segment(*a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const Segment* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Segment, &a0))
        {
            sipCpp = new Segment(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Segment[] = {
    {(void *)slot_Segment___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Segment[] = {
    {SIP_MLNAME_CAST(sipName_getFrameToTip), meth_Segment_getFrameToTip, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getFrameToTip)},
    {SIP_MLNAME_CAST(sipName_getInertia), meth_Segment_getInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getInertia)},
    {SIP_MLNAME_CAST(sipName_getJoint), meth_Segment_getJoint, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getJoint)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Segment_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getName)},
    {SIP_MLNAME_CAST(sipName_pose), meth_Segment_pose, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_pose)},
    {SIP_MLNAME_CAST(sipName_setInertia), meth_Segment_setInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_setInertia)},
    {SIP_MLNAME_CAST(sipName_twist), meth_Segment_twist, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_twist)}
};

PyDoc_STRVAR(doc_Segment, "\1Segment(string, Joint joint=Joint(Joint.None), Frame f_tip=Frame.Identity(), RigidBodyInertia I=RigidBodyInertia.Zero())\n"
    "Segment(Joint joint=Joint(Joint.None), Frame f_tip=Frame.Identity(), RigidBodyInertia I=RigidBodyInertia.Zero())\n"
    "Segment(Segment)");


sipClassTypeDef sipTypeDef_PyKDL_Segment = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Segment,
        {0}
    },
    {
        sipNameNr_Segment,
        {0, 0, 1},
        7, methods_Segment,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Segment,
    -1,
    -1,
    0,
    slots_Segment,
    init_type_Segment,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Segment,
    assign_Segment,
    array_Segment,
    copy_Segment,
    release_Segment,
    cast_Segment,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 81 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1022 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"

#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1029 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 64 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1034 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 352 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1040 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1046 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_RigidBodyInertia_Zero, "RigidBodyInertia.Zero() -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia(RigidBodyInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_Zero, doc_RigidBodyInertia_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_RefPoint, "RigidBodyInertia.RefPoint(Vector) -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const Vector* a0;
        RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ9", &sipSelf, sipType_RigidBodyInertia, &sipCpp, sipType_Vector, &a0))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_RefPoint, doc_RigidBodyInertia_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getMass, "RigidBodyInertia.getMass() -> float");

extern "C" {static PyObject *meth_RigidBodyInertia_getMass(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getMass(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getMass();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getMass, doc_RigidBodyInertia_getMass);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getCOG, "RigidBodyInertia.getCOG() -> Vector");

extern "C" {static PyObject *meth_RigidBodyInertia_getCOG(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getCOG(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            Vector*sipRes;

            sipRes = new Vector(sipCpp->getCOG());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getCOG, doc_RigidBodyInertia_getCOG);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getRotationalInertia, "RigidBodyInertia.getRotationalInertia() -> RotationalInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            RotationalInertia*sipRes;

            sipRes = new RotationalInertia(sipCpp->getRotationalInertia());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getRotationalInertia, doc_RigidBodyInertia_getRotationalInertia);

    return NULL;
}


extern "C" {static PyObject *slot_RigidBodyInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RigidBodyInertia, &a1))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const RigidBodyInertia* a0;
        const Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_Twist, &a1))
        {
            Wrench*sipRes;

            sipRes = new Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,mul_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_RigidBodyInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const RigidBodyInertia* a0;
        const RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_RigidBodyInertia, &a1))
        {
            RigidBodyInertia*sipRes;

            sipRes = new RigidBodyInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,add_slot,NULL,sipArg0,sipArg1);
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_RigidBodyInertia(void *, const sipTypeDef *);}
static void *cast_RigidBodyInertia(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_RigidBodyInertia)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_RigidBodyInertia(void *, int);}
static void release_RigidBodyInertia(void *sipCppV,int)
{
    delete reinterpret_cast<RigidBodyInertia *>(sipCppV);
}


extern "C" {static void assign_RigidBodyInertia(void *, SIP_SSIZE_T, const void *);}
static void assign_RigidBodyInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<RigidBodyInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast<const RigidBodyInertia *>(sipSrc);
}


extern "C" {static void *array_RigidBodyInertia(SIP_SSIZE_T);}
static void *array_RigidBodyInertia(SIP_SSIZE_T sipNrElem)
{
    return new RigidBodyInertia[sipNrElem];
}


extern "C" {static void *copy_RigidBodyInertia(const void *, SIP_SSIZE_T);}
static void *copy_RigidBodyInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new RigidBodyInertia(reinterpret_cast<const RigidBodyInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RigidBodyInertia(sipSimpleWrapper *);}
static void dealloc_RigidBodyInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_RigidBodyInertia(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    RigidBodyInertia *sipCpp = 0;

    {
        double a0 = 0;
        const Vector& a1def = Vector::Zero();
        const Vector* a1 = &a1def;
        const RotationalInertia& a2def = RotationalInertia::Zero();
        const RotationalInertia* a2 = &a2def;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "|dJ9J9", &a0, sipType_Vector, &a1, sipType_RotationalInertia, &a2))
        {
            sipCpp = new RigidBodyInertia(a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const RigidBodyInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RigidBodyInertia, &a0))
        {
            sipCpp = new RigidBodyInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RigidBodyInertia[] = {
    {(void *)slot_RigidBodyInertia___mul__, mul_slot},
    {(void *)slot_RigidBodyInertia___add__, add_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RigidBodyInertia[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), meth_RigidBodyInertia_RefPoint, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_RefPoint)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_RigidBodyInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_Zero)},
    {SIP_MLNAME_CAST(sipName_getCOG), meth_RigidBodyInertia_getCOG, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getCOG)},
    {SIP_MLNAME_CAST(sipName_getMass), meth_RigidBodyInertia_getMass, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getMass)},
    {SIP_MLNAME_CAST(sipName_getRotationalInertia), meth_RigidBodyInertia_getRotationalInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getRotationalInertia)}
};

PyDoc_STRVAR(doc_RigidBodyInertia, "\1RigidBodyInertia(float m=0, Vector oc=Vector.Zero(), RotationalInertia Ic=RotationalInertia.Zero())\n"
    "RigidBodyInertia(RigidBodyInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RigidBodyInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RigidBodyInertia,
        {0}
    },
    {
        sipNameNr_RigidBodyInertia,
        {0, 0, 1},
        5, methods_RigidBodyInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RigidBodyInertia,
    -1,
    -1,
    0,
    slots_RigidBodyInertia,
    init_type_RigidBodyInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RigidBodyInertia,
    assign_RigidBodyInertia,
    array_RigidBodyInertia,
    copy_RigidBodyInertia,
    release_RigidBodyInertia,
    cast_RigidBodyInertia,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 64 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1411 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"

#line 26 "/opt/ros_catkin_ws/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1418 "/opt/ros_catkin_ws/build_isolated/python_orocos_kdl/install/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_RotationalInertia_Zero, "RotationalInertia.Zero() -> RotationalInertia");

extern "C" {static PyObject *meth_RotationalInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RotationalInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
            RotationalInertia*sipRes;

            sipRes = new RotationalInertia(RotationalInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName_Zero, doc_RotationalInertia_Zero);

    return NULL;
}


extern "C" {static PyObject *slot_RotationalInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const RotationalInertia* a0;
        const RotationalInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationalInertia, &a0, sipType_RotationalInertia, &a1))
        {
            RotationalInertia*sipRes;

            sipRes = new RotationalInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,add_slot,NULL,sipArg0,sipArg1);
}


extern "C" {static PyObject *slot_RotationalInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        RotationalInertia* a0;
        Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationalInertia, &a0, sipType_Vector, &a1))
        {
            Vector*sipRes;

            sipRes = new Vector((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        double a0;
        const RotationalInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RotationalInertia, &a1))
        {
            RotationalInertia*sipRes;

            sipRes = new RotationalInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL,mul_slot,NULL,sipArg0,sipArg1);
}


/* Cast a pointer to a type somewhere in its superclass hierarchy. */
extern "C" {static void *cast_RotationalInertia(void *, const sipTypeDef *);}
static void *cast_RotationalInertia(void *ptr, const sipTypeDef *targetType)
{
    if (targetType == sipType_RotationalInertia)
        return ptr;

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_RotationalInertia(void *, int);}
static void release_RotationalInertia(void *sipCppV,int)
{
    delete reinterpret_cast<RotationalInertia *>(sipCppV);
}


extern "C" {static void assign_RotationalInertia(void *, SIP_SSIZE_T, const void *);}
static void assign_RotationalInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, const void *sipSrc)
{
    reinterpret_cast<RotationalInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast<const RotationalInertia *>(sipSrc);
}


extern "C" {static void *array_RotationalInertia(SIP_SSIZE_T);}
static void *array_RotationalInertia(SIP_SSIZE_T sipNrElem)
{
    return new RotationalInertia[sipNrElem];
}


extern "C" {static void *copy_RotationalInertia(const void *, SIP_SSIZE_T);}
static void *copy_RotationalInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new RotationalInertia(reinterpret_cast<const RotationalInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RotationalInertia(sipSimpleWrapper *);}
static void dealloc_RotationalInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsPyOwned(sipSelf))
    {
        release_RotationalInertia(sipGetAddress(sipSelf),0);
    }
}


extern "C" {static void *init_type_RotationalInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RotationalInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    RotationalInertia *sipCpp = 0;

    {
        double a0 = 0;
        double a1 = 0;
        double a2 = 0;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "|dddddd", &a0, &a1, &a2, &a3, &a4, &a5))
        {
            sipCpp = new RotationalInertia(a0,a1,a2,a3,a4,a5);

            return sipCpp;
        }
    }

    {
        const RotationalInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RotationalInertia, &a0))
        {
            sipCpp = new RotationalInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RotationalInertia[] = {
    {(void *)slot_RotationalInertia___add__, add_slot},
    {(void *)slot_RotationalInertia___mul__, mul_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RotationalInertia[] = {
    {SIP_MLNAME_CAST(sipName_Zero), meth_RotationalInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationalInertia_Zero)}
};

PyDoc_STRVAR(doc_RotationalInertia, "\1RotationalInertia(float Ixx=0, float Iyy=0, float Izz=0, float Ixy=0, float Ixz=0, float Iyz=0)\n"
    "RotationalInertia(RotationalInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RotationalInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RotationalInertia,
        {0}
    },
    {
        sipNameNr_RotationalInertia,
        {0, 0, 1},
        1, methods_RotationalInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RotationalInertia,
    -1,
    -1,
    0,
    slots_RotationalInertia,
    init_type_RotationalInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RotationalInertia,
    assign_RotationalInertia,
    array_RotationalInertia,
    copy_RotationalInertia,
    release_RotationalInertia,
    cast_RotationalInertia,
    0,
    0,
    0,
    0,
    0,
    0
};
